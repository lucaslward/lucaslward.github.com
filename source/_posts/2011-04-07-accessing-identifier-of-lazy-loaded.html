---
layout: post
title: "Accessing the identifier of a lazy loaded association in grails without another database call"
date: 2011-04-07T13:49:00-07:00
comments: false
---

<div class='post'>
I ran into a bit of a weird scenario recently with grails.  I have a couple of classes similar to those below:<br /><br /><pre class="prettyprint">class Foo {<br />Bar bar<br />}<br /><br />class Bar {<br />static hasMany = [foos: Foo]<br />}<br /></pre><br /><br />Essentially, I have a many to one relationship.  Now, consider the following code:<br /><br /><pre class="prettyprint">Foo foo = Foo.get(1)<br />Bar bar = foo.bar<br /></pre><br /><br />Assuming that there is actually a bar set on this particular foo, what will you get?<br /><br />You'll get the actual Bar, completely instantiated.  Now, imagine the exact same scenario in normal java with the exact same equivalent hibernate settings via annotations. (I'm too lazy to model what that would look like)  What would you get back for a similar call?  You would get back a proxy!  Then, if you called something on the proxy, hibernate would go and fetch the actual object for you.<br /><br /><span style="font-weight: bold;">Gorm unwraps the proxy when the object itself is called via a property.</span><br /><br />If you take a look at the HibernatePluginSupport class, which configures all of the dynamic Gorm methods (and the first place I go when I want to see how a particular method is actually working) you will see this in action:<br /><br /><pre class="prettyprint">static final LAZY_PROPERTY_HANDLER = { String propertyName -&gt;<br />  def propertyValue = PropertyUtils.getProperty(delegate, propertyName)<br />  if (propertyValue instanceof HibernateProxy) {<br />      return GrailsHibernateUtil.unwrapProxy(propertyValue)<br />  }<br />  return propertyValue<br />}<br /><br />/**<br /> * This method overrides a getter on a property that is a Hibernate proxy <br /> * in order to make sure the initialized object is returned hence avoiding <br /> * Hibernate proxy hell<br /> */<br />static void handleLazyProxy(GrailsDomainClass domainClass, <br />                            GrailsDomainClassProperty property) {<br />    String propertyName = property.name<br />    def getterName = GrailsClassUtils.getGetterName(propertyName)<br />    def setterName = GrailsClassUtils.getSetterName(propertyName)<br />    domainClass.metaClass."${getterName}" = <br />        LAZY_PROPERTY_HANDLER.curry(propertyName)<br />    domainClass.metaClass."${setterName}" = { <br />        PropertyUtils.setProperty(delegate, propertyName, it)  <br />    }<br /><br />    for (GrailsDomainClass sub in domainClass.subClasses) {<br />        handleLazyProxy(sub, sub.getPropertyByName(property.name))<br />    }<br />}<br /></pre>So, anytime you access your properties, the above code is going to unwrap it.<br /><br />What whoever wrote this is trying to avoid is the 'proxy hell' mentioned in the comment.  The hibernate docs have a good explanation of it:<br /><br /><a href="http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-fetching-lazy">http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-fetching-lazy</a><br /><br />As does the Grails docs:<br /><br /><a href="http://grails.org/doc/latest/guide/5.%20Object%20Relational%20Mapping%20%28GORM%29.html#5.5.2.8%20Eager%20and%20Lazy%20Fetching">http://grails.org/doc/latest/guide/5.%20Object%20Relational%20Mapping%20%28GORM%29.html#5.5.2.8%20Eager%20and%20Lazy%20Fetching</a><br /><br />They're more eagerly fetching the lazy relationships than Hibernate does to avoid some of the instanceof check issues outlined in the above links.<br /><br />Now, back to my issue.  What happens if you want to obtain the identifier of your relationship without actually resulting in a database call to get it?  The proxy has the identifier already, that's how it loads it up when you call it.  In pure hibernate there's a few ways to do it:<br /><ol><li>Session.getIdentifier</li><li>entity.getId() (<a href="http://256.com/gray/docs/misc/hibernate_lazy_field_access_annotations.shtml"></a><a href="http://256.com/gray/docs/misc/hibernate_lazy_field_access_annotations.shtml">assuming you are using property based configuration</a>)</li><li>Cast it to a HibernateProxy, get the LazyLoadInitializer and get the Identifier from it</li></ol>The problem with all of these solutions is that you have to get around the Gorm code above that unwraps any properties when you call a getter.  You can't just add setBar and getBar.  However, you can add another method that can get 'raw' access to the field.  And before anyone posts a comment about it you can't use load either because it requires the id, and that's the whole point of this exercise (getting the id that is). <br /><br />I didn't find this out until I had wasted quite a few hours, but apparently this was a known issue: <a href="http://jira.grails.org/browse/GRAILS-2570">http://jira.grails.org/browse/GRAILS-2570</a> I never saw this when googling for it originally, but you can essentially say:<br /><br /><pre class="prettyprint">foo.barId</pre><br /><br />And you will get the id of the bar without the proxy being unwrapped.  I'm not sure this is referenced anywhere in the docs though.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>timbonicus</div>
<div class='content'>
Thanks for putting this information out there, you saved me a few hours of frustration!</div>
</div>
<div class='comment'>
<div class='author'>Manuel</div>
<div class='content'>
Great post, thanks! Already bookmarked this for future reference!</div>
</div>
<div class='comment'>
<div class='author'>Amit</div>
<div class='content'>
Thanks for posting this!</div>
</div>
</div>
